# Software Architecture

2010년도 이후부터는 Resilient/Anti-Fragile, Cloud Native의 키워드로 볼 수 있다. 시스템이 로컬에서 클라우드로 이전되었고 확장성과 안정성이 더 강화되었으며 지속적인 변경사항이 생겨도 시스템을 안정적 + 탄력적으로 운영이 가능해지게 되었다. Anti-Fragile환경으로 인해 DevOps라는 IT 문화가 생겨났고 IT 아키텍처로는 Cloud Native 아키텍처로 전환되었다. 

## **Antifragile 4가지 핵심**

### Auto scaling

- 자동 확장성을 가진다. 시스템을 구성하는 하나의 인스턴스를 오토 스케일링 그룹으로 묶은 다음, 유지되어야하는 최소 인스턴스를 지정할 수 있고, 사용량에 따라 자동으로 인스턴스를 증가할 수 있는 환경을 말한다.
- 온라인 휴양지 예약 시스템. 성수기에는 서버의 수를 늘리고 비수기에는 줄이는, 이걸 사용자가 직접 하지 않고, 수작업이 아닌 조건에 따라 자동으로 처리할 수 있다.

### Microservices

- 넷플릭스와 아마존이 클라우드 서비스를 아주 잘 활용하는 기업들이다. 클라우드 네이티브 아키텍처/어플리케이션의 핵심이다. 기존의 시스템들이 하나의 거대한 형태로 구축되었다하면, Microservices는 전체 서비스를 구축하고 있는 모듈이나 기능을 독립적으로 개발/배포/운영할 수 있게 세분화된 서비스이다.

### Chaos engineer

- 시스템이 예상치 못한 상황/불확실성에도 안정적/신뢰적으로 실행할 수 있게 하는 방법이다.

### Continuous deployments

- CI/CD와 같은 배포 파이프라인. 지속적인 통합/배포를 의미한다. 도메인이 수십개, 수백개로 나누어져 있다. 이것들을 모두 따로 개발하고 빌드하고 배포하는것이 작업로드의 큰 부분을 차지하게 된다. 자동화된 서비스를 구축 + 파이프라인으로 연결하여 생산성/효율성이 증가한다.

# Cloud Native Architecture

### 특징

1. 확장 가능한 아키텍처
    - 시스템의 수평적 확정에 유연
    - 확정된 서버로 시스템의 부하 분산, 가용성 보장
        - 스케일 업 : 하드웨어의 사양을 높이는 방법
        - 스케일 아웃 : 같은 사양의 서버(인스턴스)를 여러개 배치하여 동시에 여러명의 사용자의 요청 처리 가능
    - 시스템 또는 서비스 애플리케이션 단위의 패키지(컨테이너 기반 패키지)
    - 모니터링
        - 현재 사용중인 리소스를 모니터링 가능하다.
2. 탄력적 아키텍처
    - 서비스 생성 - 통합 - 배포, 비즈니스 환경 변화에 대응 시간 단축
        - CI/CD
    - 분할된 서비스 구조
        - 작게 분리된 독립적인 서비스이므로 도메인의 특성에 따라 구분하고 개발해야한다. 원활한 통신을 위해 각각의 서비스는 종속성을 최소화해야한다.
    - 무상태 통신 프로토콜
        - 상태를 갖지 않는 서비스를 제공해야 한다.
    - 서비스의 추가와 삭제 자동으로 감지
        - 마이크로 서비스들은 배포될 때 자신들의 위치가 어디인지 등록해야한다.
        - 그래야 다른 서비스에서 해당 서비스를 검색/등록/사용이 가능하다.
    - 변경된 서비스 요청에 따라 사용자 요청 처리 (동적 처리)
3. 장애 격리(Fault isolation)
    - 장애 복구에 뛰어남
    - 특정 서비스에 오류가 발생해도 다른 서비스에 영향 주지 않음

# Cloud Native Application

> 클라우드 네이티브 아키텍처에 의해 설계되고 구현되는 어플리케이션을 클라우드 네이티브 어플리케이션이라고 함
> 


### 구현되는 형태

1. Microservices로 개발
2. CI/CD로 통합
    - 개발된 마이크로 서비스들은 CI-CD 시스템에 의해서 자동으로 통합
    - 빌드, 테스트, 배포라는 과정을 거치게 됨
3. DevOps
    - 마이크로 서비스에 문제가 발생하였을 경우에 바로바로 수정해서 다시 배포하는 과정을 반복할 수 있는 형태
    - 이 특징을 DevOps라고 함
    - 처음에 시스템이 기획, 구현, 테스트, 배포되는 과정을 시스템이 종료될때까지 무한으로 반복해줌으로써 고객이 원하는 최선의 결과물을 만드는데 목적을 두고 있음
4. Containers
    - 하나의 어플리케이션을 구성하는 마이크로 서비스들을 클라우드 환경에 배포하고 사용하기 위해서는 컨테이너 가상화 기술을 사용함

### CI/CD 특징

- 지속적인 통합 (CI, Continuous Integration)
    - 결과물을 통합하기 위한 형성관리를 뜻할 수도 있음
    - 통합서버, 소스관리(scm), 빌드도구, 테스트도구
        - ex) Jenkins, Team CI, Travis CI
- 지속적인 배포 (Cotinuous Delivery, Continuous Deployment, Pipeline)
    - 지속적인 전달과 배포
    - 패키지화 되어있는 결과물을 수동 반영 : continous delivery
    - 관리자의 개입없이 자동화되어있는 배포 : continous deployment
- 카나리 배포와 블루그린 배포
    - 시스템에 완성된 결과물을 배포하기 위해 선택하는 전략
    - 95%의 사용자는 기존의 서비스, 5%의 사용자는 새로운 버전의 서비스를 사용하게 한다던가
    - 이전 버전의 사용자 트래픽을 이전 버전과 거의 동일한 새 버전으로 점진적으로 이전시키는 방법

    

### DevOps 특징

> Development + Operations의 합성어
개발조직과 운영조직의 통합을 의미
> 


- 고객의 요구사항을 빠르게 반영하고 만족도 높은 결과물을 제시하는 것이 목적
- 개발 기간이 길어지면 변경사항과 요구사항에 빠르게 대처하기가 어려움
- 필요할 때마다 바로 반영이되고, 수정할 수 있는 구조가 best
- 잦은 테스트, 피드백, 업데이트 과정을 거쳐 개발 일정이 완료될때까지 지속적으로 진행하는것을 DevOps라고 할 수 있음

### Container 가상화

가상화는 클라우드 네이티브 아키텍처의 가장 큰 특징 중에 하나임 

기존의 로컬환경에서 운영되고 있는 시스템을 클라우드로 이전해서 적은 비용으로 탄력적으로 운영 가능하게 만들어준 기능이다. 기존의 하드웨어 가상화, 서버 가상화보다 적은 리소스를 이용하여 가상화 서비스를 구축할 수 있다.


1. 전통적인 방식의 개발 시스템
    - 하드웨어 시스템 위에 운영체제를 설치하고, 어플리케이션을 운영
2. 가상화를 통한 개발 시스템
    - 운영체제(OS)위에 Hypervisor 기술을 통한 가상머신을 기동
    - 가상 머신은 시스템이 가지고 있는 물리적인 하드웨어, 호스트 시스템이 가지고 있는 물리적인 하드웨어를 쪼개서 사용하는 개념
    - 하나의 가상 머신은 독립적인 운영체제를 가지고 실행됨
    
    ---
    
    - 그러나 호스트 운영체제에 많은 부하를 주고, 시스템 확장에 한계가 있음
3. 컨테이너 가상화 기술 기반의 개발 시스템 
    - OS위에 컨테이너 가상화를 기동하기 위한 소프트 웨어 서비스(Container Runtime)를 작동
    - 컨테이너 가상화에서는 공통적인 라이브러리나 리소스 등을 공유해서 사용하게 됨
    - 각자 필요한 부분에 대해서만 독립적인 영역에다가 실행할 수 있는 구조
    
    ---
    
    - 기존의 하드웨어 가상화 기술보다는 더 적은 리소스를 사용
    - 컨테이너 가상화 위에서 작동되는 서비스들은 가볍고 빠르게 운영할 수 있음

# 고려할 12가지 항목


1. 코드 통합
2. 종속성의 배제
3. 환경 설정의 외부관리
4. 백업 서비스의 분리
5. 개발 환경과 테스트 운영 환경의 분리
6. 상태 관리
7. 포트 바인딩 
8. 동시성
9. 서비스의 올바른 상태 유지
10. 개발과 운영 환경의 통일
11. 로그의 분리
12. 관리 프로세스 

# Monolithic vs Microservice

## Monolithic(모노리스)

> 애플리케이션을 개발함에 있어서 필요한 모든 요소를 하나의 커다란 소프트웨어 안에서 전부 포함시켜 개발하는 방법
> 
- 모든 업무 로직이 하나의 애플리케이션 형태로 패키지되어 서비스
- 애플리케이션에서 사용하는 데이터가 한 곳에 모여 참조되어 서비스되는 형태

### 단점

- 하나의 시스템에 어플리케이션을 구성하고 있는 모든 서비스와 요소들을 패키징 되어서 서비스가 되어야 하기 때문에 시스템의 일부만 수정한다 하더라도 전체 어플리케이션을 다시 빌드하고 패키징 해야함

## Microservice

> 애플리케이션을 구성하는 각각의 구성 요소 및 서비스의 내용을 분리해서 개발하고 운영하는 방식 
각각의 용도에 맞는 컨테이너를 모아서 사용하는 서비스
> 

### 장점

- 모노리스 방식에 비해서 유지보수나 변경사항을 적용하는데 훨씬 유리
- 필요한 부분에 대해서만 개발을 하고 분리된 서비스가 다른 서비스에 영향을 최소화하면서 독립적으로 배포 가능
- 애플리케이션 전체가 다운되는 현상을 없앨 수 있음


# Microservice Architecture


클라우드 서비스를 가장 활발히 사용하고 있는 서비스 

### 마이크로 서비스의 특징

1. Challenges
    - 기존의 개발 방식과 패러다임을 상당수 바꿔야한다
2. Small Well Chosen Deployable Units
    - 독립적으로 배포 가능한 형태의 작은 서비스로 이루어져 있어야 한다
3. Bounded Context
    - 각각의 서비스들은 어플리케이션을 구성하고 있는 전체 도메인의 지식에 따라서 서비스 경계를 잘 구분해야하고
    - 이런 서비스 경계 구분에 의해서 하나의 서비스가 두 개가 되기도 하고 여러 개의 서비스가 단일화된 서비스 형태 하나로 만들어지기도 함
4. RESTful
    - 각각의 서비스들은 서로 상태에 대해서 REST API 방식으로 통신하는 것을 권장함(서비스 인터페이스)
    - REST API는 HTTP 프로토콜을 기반으로 해서 JSON 포맷을 이용함
    - 경량 데이터 포맷이기 때문에 서버의 리소스, 다음의 서버가 가지고 있는 상태를 표시하기에 최적화되어 있는 포맷이라고 생각함
5. Configuration Management
    - 프로그래밍을 하면서 하드 코딩되어야 하는 몇 가지 정보가 있음
    - 하드 코딩해버리게 되면 그 정보가 같이 패키징되어서 배포가 되어야함
    - 수정하려면 그러한 내용들도 같이 수정해서 다시 배포해야함
    - 마이크로 서비스로 쪼갰다 하더라도 변경되는 코드는 다시 패키징을 하고 배포가 필요하다
    - 하지만 설정정보 같은 경우에는 서버가 다시 배포될 필요는 없다
    - 이러한 정보를 환경 설정 정보라 하고, 외후에 두어서 관리하는 것을 권장한다
6. Cloud Enabled
    - 클라우드 네이티브 기술을 최대한 활용해서 서비스를 제공함
7. Dynamic Scale Up And Scale Down
    - 서비스를 제공하는 인스턴스들은 부하 분산 처리나 스케일업, 스케일다운 등을 동적으로 처리할 수 있도록 구성되어 있어야함
8. CI/CD
9. Visibility 
    - 마이크로 서비스들은 시각화할 수 있는 도구를 같이 가지고 있어야함

### 고려사항

1. Multiple Rates of Change
    - 어느 정도 변화가 생길 것인가
    - 기존 개발 대비 비용,시간을 더 투자해야함
2. Independent Life Cycles
    - 독립 라이프 사이클
    - 어플리케이션을 구성하고 있는 각각의 서비스들이 독립적으로 개발되고 운영될 수 있도록 서비스 경계가 잘 만들어져 있는가
3. Independent Scalability
    - 독립적인 확장성
    - 각각의 서비스를 운영함에 있어서 서비스 유지 보수 및 확장성이 가능한가, 스케일링이 쉽게 되어 있는가
4. Isolated Failure
    - 격리된 오류
    - 오류사항이 독립적인가
    - 마이크로 서비스에 부분적인 오류가 발생되었을때 해당 서비스에 대해서만 오류가 영향을 받도록 설계되었는지
    - 다른 마이크로 서비스들은 오류에 최소한의 영향을 받으면서 해당 서비스를 우회화할 수 있는 대체 서비스가 준비되어 있는지를 고려
5. Simplify Interactions with External Dependencies
    - 외부 종속성과의 상호작용을 단순화 해야함
    - 시스템이나 서비스 간의 종속성을 최소화하고 응집력을 높일수 있도록 서비스 경계가 잘 구분되어 있는가를 고려
6. Polyglot Technology
    - 여러가지 프로그램 언어, 여러가지 스토리지 기술 등을 쓸 수 있게끔 지원되는 패러다임이 폴리그랏이라고 함

# SOA vs MSA

> SOA : Service Original Architecture
MSA : Micro Service Architecture
> 

## 공통점

- 서비스를 지향

## 차이점

### 서비스의 공유 지향점

- SOA - 서비스의 재사용을 통한 비용 절감이 주 목적
- MSA - 서비스 간의 결합도를 낮추어 변화에 능동적으로 대응이 주 목적


### 기술 방식

- SOA
    - 공통의 서비스를 ESB에 모아 사업 측면에서 공통 서비스 형식으로 서비스 제공
    - SOAP 프로토콜을 이용하는 기존의 웹 서비스 방식을 사용
- MSA
    - 각 독립된 서비스가 노출된 REST API를 주로 사용


### 서비스 예시

- SOA
    - 각각의 서비스들은 ESB(엔터프라이즈 서비스 버스)에 모임
    - 모여진 서비스들이 웹서비스 기술을 통해 외부에 공개됨
    - 데이터 베이스의 자료를 저장하기 위해서 공통적인 데이터베이스 처리로직(SOAP, HTTP, JMS, JDBC)을 사용할 수 있음
- MSA
    - 각각의 서비스들은 독립적인 개발 프로세스를 가짐
    - 각 서비스는 자신의 데이터를 외부에 공개할 때 REST API를 통해서 공개
    - 이벤트 스트림 방식과 같은 메시징 서비스를 이용해서 데이터 동기화할 수 있음
    - 각 DB에 저장된 데이터들은 카프카라는 메시징 서비스를 이용해 서로간에 필요한 데이터를 동기화할 수 있음
        - 데이터가 변경되면 그걸 카프카에 전달하기만함(누가 받을진 관심X)
        - 카프카가 이 데이터가 관심있다고 등록을 했던 객체들한테 변경된 데이터를 배달해줌
        - 배달받은 데이터 값을 자신이 가지고 있는 DB에 업데이트함



# MSA의 컴포넌스 구성도


1. 클라이언트들이나 다른 마이크로 서비스가 API Gateway를 통해서 서비스를 요청
2. 수집된 클라이언트들의 요청은 서비스 라우터에게 어디로 가야할지 물어봄
3. 필요한 마이크로 서비스가 어디에 저장되어 있는지 서비스 디스커버리의 등록 서비스를 확인
4. 마이크로 서비스의 위치를 알았으면 로드 밸런싱을 통해 마이크로 서비스로 이동 
5. 마이크로 서비스 내의 환경설정 정보는 외부 시스템에 저장 시키는게 일반적
6. 완성된 어플리케이션은 CI-CD 자동화 기술을 사용해 배포
7. 외부 시스템에 배포할 때 관리자나 DevOps 관련된 사용자들이 사용할 수 있게 API가 공개되어야함
8. MOM(메시징 처리 시스템)을 통해서 하나의 서비스와 다른 서비스가 연결될 수 있음 

## 서비스 메쉬(Service Mesh)

> 서비스 메쉬는 마이크로 서비스 아키텍처 시스템의 내부통신을 말함
> 
- MSA 인프라 → 미들웨어
    - 프록시 역할, 인증, 권한 부여, 암호화, 서비스 검핵, 요청 라우팅, 로드 밸런싱
    - 자가 치유 복구 서비스
- 서비스간의 통신과 관련된 기능을 자동화
